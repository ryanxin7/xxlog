{
  "version": 3,
  "sources": ["../../../../node_modules/mermaid/src/diagrams/flowchart/elk/render-utils.ts", "../../../../node_modules/mermaid/src/diagrams/flowchart/elk/flowRenderer-elk.js", "../../../../node_modules/mermaid/src/diagrams/flowchart/elk/styles.ts", "../../../../node_modules/mermaid/src/diagrams/flowchart/elk/flowchart-elk-definition.ts"],
  "sourcesContent": ["export interface TreeData {\n  parentById: Record<string, string>;\n  childrenById: Record<string, string[]>;\n}\n\nexport const findCommonAncestor = (id1: string, id2: string, treeData: TreeData) => {\n  const { parentById } = treeData;\n  const visited = new Set();\n  let currentId = id1;\n  while (currentId) {\n    visited.add(currentId);\n    if (currentId === id2) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  currentId = id2;\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  return 'root';\n};\n", "import { select, line, curveLinear } from 'd3';\nimport { insertNode } from '../../../dagre-wrapper/nodes.js';\nimport insertMarkers from '../../../dagre-wrapper/markers.js';\nimport { insertEdgeLabel } from '../../../dagre-wrapper/edges.js';\nimport { findCommonAncestor } from './render-utils';\nimport { addHtmlLabel } from 'dagre-d3-es/src/dagre-js/label/add-html-label.js';\nimport { getConfig } from '../../../config';\nimport { log } from '../../../logger';\nimport { setupGraphViewbox } from '../../../setupGraphViewbox';\nimport common, { evaluate } from '../../common/common';\nimport { interpolateToCurve, getStylesFromArray } from '../../../utils';\n\nlet elk;\n\nconst portPos = {};\n\nconst conf = {};\nexport const setConf = function (cnf) {\n  const keys = Object.keys(cnf);\n  for (const key of keys) {\n    conf[key] = cnf[key];\n  }\n};\n\nlet nodeDb = {};\n\n// /**\n//  * Function that adds the vertices found during parsing to the graph to be rendered.\n//  *\n//  * @param vert Object containing the vertices.\n//  * @param g The graph that is to be drawn.\n//  * @param svgId\n//  * @param root\n//  * @param doc\n//  * @param diagObj\n//  */\nexport const addVertices = function (vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert('g').attr('class', 'nodes');\n  const keys = Object.keys(vert);\n\n  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n  keys.forEach(function (id) {\n    const vertex = vert[id];\n\n    /**\n     * Variable for storing the classes for the vertex\n     *\n     * @type {string}\n     */\n    let classStr = 'default';\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(' ');\n    }\n\n    const styles = getStylesFromArray(vertex.styles);\n\n    // Use vertex id as text in the box if no text is provided by the graph definition\n    let vertexText = vertex.text !== undefined ? vertex.text : vertex.id;\n\n    // We create a SVG label, either by delegating to addHtmlLabel or manually\n    let vertexNode;\n    const labelData = { width: 0, height: 0 };\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n      const node = {\n        label: vertexText.replace(\n          /fa[blrs]?:fa-[\\w-]+/g,\n          (s) => `<i class='${s.replace(':', ' ')}'></i>`\n        ),\n      };\n      vertexNode = addHtmlLabel(svg, node).node();\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n      vertexNode.parentNode.removeChild(vertexNode);\n    } else {\n      const svgLabel = doc.createElementNS('http://www.w3.org/2000/svg', 'text');\n      svgLabel.setAttribute('style', styles.labelStyle.replace('color:', 'fill:'));\n\n      const rows = vertexText.split(common.lineBreakRegex);\n\n      for (const row of rows) {\n        const tspan = doc.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n        tspan.setAttribute('dy', '1em');\n        tspan.setAttribute('x', '1');\n        tspan.textContent = row;\n        svgLabel.appendChild(tspan);\n      }\n      vertexNode = svgLabel;\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n    }\n\n    const ports = [\n      {\n        id: vertex.id + '-west',\n        layoutOptions: {\n          'port.side': 'WEST',\n        },\n      },\n      {\n        id: vertex.id + '-east',\n        layoutOptions: {\n          'port.side': 'EAST',\n        },\n      },\n      {\n        id: vertex.id + '-south',\n        layoutOptions: {\n          'port.side': 'SOUTH',\n        },\n      },\n      {\n        id: vertex.id + '-north',\n        layoutOptions: {\n          'port.side': 'NORTH',\n        },\n      },\n    ];\n\n    let radious = 0;\n    let _shape = '';\n    let layoutOptions = {};\n    // Set the shape based parameters\n    switch (vertex.type) {\n      case 'round':\n        radious = 5;\n        _shape = 'rect';\n        break;\n      case 'square':\n        _shape = 'rect';\n        break;\n      case 'diamond':\n        _shape = 'question';\n        layoutOptions = {\n          portConstraints: 'FIXED_SIDE',\n        };\n        break;\n      case 'hexagon':\n        _shape = 'hexagon';\n        break;\n      case 'odd':\n        _shape = 'rect_left_inv_arrow';\n        break;\n      case 'lean_right':\n        _shape = 'lean_right';\n        break;\n      case 'lean_left':\n        _shape = 'lean_left';\n        break;\n      case 'trapezoid':\n        _shape = 'trapezoid';\n        break;\n      case 'inv_trapezoid':\n        _shape = 'inv_trapezoid';\n        break;\n      case 'odd_right':\n        _shape = 'rect_left_inv_arrow';\n        break;\n      case 'circle':\n        _shape = 'circle';\n        break;\n      case 'ellipse':\n        _shape = 'ellipse';\n        break;\n      case 'stadium':\n        _shape = 'stadium';\n        break;\n      case 'subroutine':\n        _shape = 'subroutine';\n        break;\n      case 'cylinder':\n        _shape = 'cylinder';\n        break;\n      case 'group':\n        _shape = 'rect';\n        break;\n      case 'doublecircle':\n        _shape = 'doublecircle';\n        break;\n      default:\n        _shape = 'rect';\n    }\n    // Add the node\n    const node = {\n      labelStyle: styles.labelStyle,\n      shape: _shape,\n      labelText: vertexText,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles.style,\n      id: vertex.id,\n      link: vertex.link,\n      linkTarget: vertex.linkTarget,\n      tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      haveCallback: vertex.haveCallback,\n      width: vertex.type === 'group' ? 500 : undefined,\n      dir: vertex.dir,\n      type: vertex.type,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding,\n    };\n    let boundingBox;\n    let nodeEl;\n    if (node.type !== 'group') {\n      nodeEl = insertNode(nodes, node, vertex.dir);\n      boundingBox = nodeEl.node().getBBox();\n    }\n\n    const data = {\n      id: vertex.id,\n      ports: vertex.type === 'diamond' ? ports : [],\n      // labelStyle: styles.labelStyle,\n      // shape: _shape,\n      layoutOptions,\n      labelText: vertexText,\n      labelData,\n      // labels: [{ text: vertexText }],\n      // rx: radius,\n      // ry: radius,\n      // class: classStr,\n      // style: styles.style,\n      // link: vertex.link,\n      // linkTarget: vertex.linkTarget,\n      // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      // haveCallback: vertex.haveCallback,\n      width: boundingBox?.width,\n      height: boundingBox?.height,\n      // dir: vertex.dir,\n      type: vertex.type,\n      // props: vertex.props,\n      // padding: getConfig().flowchart.padding,\n      // boundingBox,\n      el: nodeEl,\n      parent: parentLookupDb.parentById[vertex.id],\n    };\n    // if (!Object.keys(parentLookupDb.childrenById).includes(vertex.id)) {\n    // graph.children.push({\n    //   ...data,\n    // });\n    // }\n    nodeDb[node.id] = data;\n    // log.trace('setNode', {\n    //   labelStyle: styles.labelStyle,\n    //   shape: _shape,\n    //   labelText: vertexText,\n    //   rx: radius,\n    //   ry: radius,\n    //   class: classStr,\n    //   style: styles.style,\n    //   id: vertex.id,\n    //   domId: diagObj.db.lookUpDomId(vertex.id),\n    //   width: vertex.type === 'group' ? 500 : undefined,\n    //   type: vertex.type,\n    //   dir: vertex.dir,\n    //   props: vertex.props,\n    //   padding: getConfig().flowchart.padding,\n    //   parent: parentLookupDb.parentById[vertex.id],\n    // });\n  });\n  return graph;\n};\n\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos = {\n    TB: {\n      in: {\n        north: 'north',\n      },\n      out: {\n        south: 'west',\n        west: 'east',\n        east: 'south',\n      },\n    },\n    LR: {\n      in: {\n        west: 'west',\n      },\n      out: {\n        east: 'south',\n        south: 'north',\n        north: 'east',\n      },\n    },\n    RL: {\n      in: {\n        east: 'east',\n      },\n      out: {\n        west: 'north',\n        north: 'south',\n        south: 'west',\n      },\n    },\n    BT: {\n      in: {\n        south: 'south',\n      },\n      out: {\n        north: 'east',\n        east: 'west',\n        west: 'north',\n      },\n    },\n  };\n  portPos.TD = portPos.TB;\n  log.info('abc88', graphDirection, edgeDirection, position);\n  return portPos[graphDirection][edgeDirection][position];\n  // return 'south';\n};\n\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info('getNextPort abc88', { node, edgeDirection, graphDirection });\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case 'TB':\n      case 'TD':\n        portPos[node] = {\n          inPosition: 'north',\n          outPosition: 'south',\n        };\n        break;\n      case 'BT':\n        portPos[node] = {\n          inPosition: 'south',\n          outPosition: 'north',\n        };\n        break;\n      case 'RL':\n        portPos[node] = {\n          inPosition: 'east',\n          outPosition: 'west',\n        };\n        break;\n      case 'LR':\n        portPos[node] = {\n          inPosition: 'west',\n          outPosition: 'east',\n        };\n        break;\n    }\n  }\n  const result = edgeDirection === 'in' ? portPos[node].inPosition : portPos[node].outPosition;\n\n  if (edgeDirection === 'in') {\n    portPos[node].inPosition = getNextPosition(\n      portPos[node].inPosition,\n      edgeDirection,\n      graphDirection\n    );\n  } else {\n    portPos[node].outPosition = getNextPosition(\n      portPos[node].outPosition,\n      edgeDirection,\n      graphDirection\n    );\n  }\n  return result;\n};\n\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n\n  if (!startNode || !endNode) {\n    return { source, target };\n  }\n\n  if (startNode.type === 'diamond') {\n    source = `${source}-${getNextPort(source, 'out', dir)}`;\n  }\n\n  if (endNode.type === 'diamond') {\n    target = `${target}-${getNextPort(target, 'in', dir)}`;\n  }\n\n  // Add the edge to the graph\n  return { source, target };\n};\n\n/**\n * Add edges to graph based on parsed graph definition\n *\n * @param {object} edges The edges to add to the graph\n * @param {object} g The graph object\n * @param cy\n * @param diagObj\n * @param graph\n * @param svg\n */\nexport const addEdges = function (edges, diagObj, graph, svg) {\n  log.info('abc78 edges = ', edges);\n  const labelsEl = svg.insert('g').attr('class', 'edgeLabels');\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n\n  if (edges.defaultStyle !== undefined) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n\n  edges.forEach(function (edge) {\n    // Identify Link\n    var linkIdBase = 'L-' + edge.start + '-' + edge.end;\n    // count the links from+to the same node to give unique id\n    if (linkIdCnt[linkIdBase] === undefined) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n    }\n    let linkId = linkIdBase + '-' + linkIdCnt[linkIdBase];\n    log.info('abc78 new link id to be used is', linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    var linkNameStart = 'LS-' + edge.start;\n    var linkNameEnd = 'LE-' + edge.end;\n\n    const edgeData = { style: '', labelStyle: '' };\n    edgeData.minlen = edge.length || 1;\n    //edgeData.id = 'id' + cnt;\n\n    // Set link type for rendering\n    if (edge.type === 'arrow_open') {\n      edgeData.arrowhead = 'none';\n    } else {\n      edgeData.arrowhead = 'normal';\n    }\n\n    // Check of arrow types, placed here in order not to break old rendering\n    edgeData.arrowTypeStart = 'arrow_open';\n    edgeData.arrowTypeEnd = 'arrow_open';\n\n    /* eslint-disable no-fallthrough */\n    switch (edge.type) {\n      case 'double_arrow_cross':\n        edgeData.arrowTypeStart = 'arrow_cross';\n      case 'arrow_cross':\n        edgeData.arrowTypeEnd = 'arrow_cross';\n        break;\n      case 'double_arrow_point':\n        edgeData.arrowTypeStart = 'arrow_point';\n      case 'arrow_point':\n        edgeData.arrowTypeEnd = 'arrow_point';\n        break;\n      case 'double_arrow_circle':\n        edgeData.arrowTypeStart = 'arrow_circle';\n      case 'arrow_circle':\n        edgeData.arrowTypeEnd = 'arrow_circle';\n        break;\n    }\n\n    let style = '';\n    let labelStyle = '';\n\n    switch (edge.stroke) {\n      case 'normal':\n        style = 'fill:none;';\n        if (defaultStyle !== undefined) {\n          style = defaultStyle;\n        }\n        if (defaultLabelStyle !== undefined) {\n          labelStyle = defaultLabelStyle;\n        }\n        edgeData.thickness = 'normal';\n        edgeData.pattern = 'solid';\n        break;\n      case 'dotted':\n        edgeData.thickness = 'normal';\n        edgeData.pattern = 'dotted';\n        edgeData.style = 'fill:none;stroke-width:2px;stroke-dasharray:3;';\n        break;\n      case 'thick':\n        edgeData.thickness = 'thick';\n        edgeData.pattern = 'solid';\n        edgeData.style = 'stroke-width: 3.5px;fill:none;';\n        break;\n    }\n    if (edge.style !== undefined) {\n      const styles = getStylesFromArray(edge.style);\n      style = styles.style;\n      labelStyle = styles.labelStyle;\n    }\n\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n\n    if (edge.interpolate !== undefined) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== undefined) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n\n    if (edge.text === undefined) {\n      if (edge.style !== undefined) {\n        edgeData.arrowheadStyle = 'fill: #333';\n      }\n    } else {\n      edgeData.arrowheadStyle = 'fill: #333';\n      edgeData.labelpos = 'c';\n    }\n\n    edgeData.labelType = 'text';\n    edgeData.label = edge.text.replace(common.lineBreakRegex, '\\n');\n\n    if (edge.style === undefined) {\n      edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none;';\n    }\n\n    edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:');\n\n    edgeData.id = linkId;\n    edgeData.classes = 'flowchart-link ' + linkNameStart + ' ' + linkNameEnd;\n\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n\n    // calculate start and end points of the edge\n    const { source, target } = getEdgeStartEndPoint(edge, dir);\n    log.debug('abc78 source and target', source, target);\n    // Add the edge to the graph\n    graph.edges.push({\n      id: 'e' + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      labelEl: labelEl,\n      labels: [\n        {\n          width: edgeData.width,\n          height: edgeData.height,\n          orgWidth: edgeData.width,\n          orgHeight: edgeData.height,\n          text: edgeData.label,\n          layoutOptions: {\n            'edgeLabels.inline': 'true',\n            'edgeLabels.placement': 'CENTER',\n          },\n        },\n      ],\n      edgeData,\n    });\n  });\n  return graph;\n};\n\n// TODO: break out and share with dagre wrapper. The current code in dagre wrapper also adds\n// adds the line to the graph, but we don't need that here. This is why we cant use the dagre\n// wrapper directly for this\n/**\n * Add the markers to the edge depending on the type of arrow is\n * @param svgPath\n * @param edgeData\n * @param diagramType\n * @param arrowMarkerAbsolute\n */\nconst addMarkersToEdge = function (svgPath, edgeData, diagramType, arrowMarkerAbsolute) {\n  let url = '';\n  // Check configuration for absolute path\n  if (arrowMarkerAbsolute) {\n    url =\n      window.location.protocol +\n      '//' +\n      window.location.host +\n      window.location.pathname +\n      window.location.search;\n    url = url.replace(/\\(/g, '\\\\(');\n    url = url.replace(/\\)/g, '\\\\)');\n  }\n\n  // look in edge data and decide which marker to use\n  switch (edgeData.arrowTypeStart) {\n    case 'arrow_cross':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-crossStart' + ')');\n      break;\n    case 'arrow_point':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-pointStart' + ')');\n      break;\n    case 'arrow_barb':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-barbStart' + ')');\n      break;\n    case 'arrow_circle':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-circleStart' + ')');\n      break;\n    case 'aggregation':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-aggregationStart' + ')');\n      break;\n    case 'extension':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-extensionStart' + ')');\n      break;\n    case 'composition':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-compositionStart' + ')');\n      break;\n    case 'dependency':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-dependencyStart' + ')');\n      break;\n    case 'lollipop':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-lollipopStart' + ')');\n      break;\n    default:\n  }\n  switch (edgeData.arrowTypeEnd) {\n    case 'arrow_cross':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-crossEnd' + ')');\n      break;\n    case 'arrow_point':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-pointEnd' + ')');\n      break;\n    case 'arrow_barb':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-barbEnd' + ')');\n      break;\n    case 'arrow_circle':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-circleEnd' + ')');\n      break;\n    case 'aggregation':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-aggregationEnd' + ')');\n      break;\n    case 'extension':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-extensionEnd' + ')');\n      break;\n    case 'composition':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-compositionEnd' + ')');\n      break;\n    case 'dependency':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-dependencyEnd' + ')');\n      break;\n    case 'lollipop':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-lollipopEnd' + ')');\n      break;\n    default:\n  }\n};\n\n/**\n * Returns the all the styles from classDef statements in the graph definition.\n *\n * @param text\n * @param diagObj\n * @returns {object} ClassDef styles\n */\nexport const getClasses = function (text, diagObj) {\n  log.info('Extracting classes');\n  diagObj.db.clear('ver-2');\n  try {\n    // Parse the graph definition\n    diagObj.parse(text);\n    return diagObj.db.getClasses();\n  } catch (e) {\n    return {};\n  }\n};\n\nconst addSubGraphs = function (db) {\n  const parentLookupDb = { parentById: {}, childrenById: {} };\n  const subgraphs = db.getSubGraphs();\n  log.info('Subgraphs - ', subgraphs);\n  subgraphs.forEach(function (subgraph) {\n    subgraph.nodes.forEach(function (node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n      if (parentLookupDb.childrenById[subgraph.id] === undefined) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n\n  subgraphs.forEach(function (subgraph) {\n    const data = { id: subgraph.id };\n    if (parentLookupDb.parentById[subgraph.id] !== undefined) {\n      data.parent = parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\n\nconst calcOffset = function (src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n  if (ancestor === undefined || ancestor === 'root') {\n    return { x: 0, y: 0 };\n  }\n\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return { x: ancestorOffset.posX, y: ancestorOffset.posY };\n};\n\nconst insertEdge = function (edgesEl, edge, edgeData, diagObj, parentLookupDb) {\n  const offset = calcOffset(edge.sources[0], edge.targets[0], parentLookupDb);\n\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n\n  const segPoints = segments.map((segment) => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [\n    [src.x + offset.x, src.y + offset.y],\n    ...segPoints,\n    [dest.x + offset.x, dest.y + offset.y],\n  ];\n\n  // const curve = line().curve(curveBasis);\n  const curve = line().curve(curveLinear);\n  const edgePath = edgesEl\n    .insert('path')\n    .attr('d', curve(points))\n    .attr('class', 'path')\n    .attr('fill', 'none');\n  const edgeG = edgesEl.insert('g').attr('class', 'edgeLabel');\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr('width', box.width);\n  edgeWithLabel.attr('height', box.height);\n\n  edgeG.attr(\n    'transform',\n    `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`\n  );\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute);\n};\n\n/**\n * Recursive function that iterates over an array of nodes and inserts the children of each node.\n * It also recursively populates the inserts the children of the children and so on.\n * @param {*} graph\n * @param nodeArray\n * @param parentLookupDb\n */\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach((node) => {\n    // Check if we have reached the end of the tree\n    if (!node.children) {\n      node.children = [];\n    }\n    // Check if the node has children\n    const childIds = parentLookupDb.childrenById[node.id];\n    // If the node has children, add them to the node\n    if (childIds) {\n      childIds.forEach((childId) => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n    // Recursive call\n    insertChildren(node.children, parentLookupDb);\n  });\n};\n\n/**\n * Draws a flowchart in the tag with id: id based on the graph definition in text.\n *\n * @param text\n * @param id\n */\n\nexport const draw = async function (text, id, _version, diagObj) {\n  if (!elk) {\n    const ELK = (await import('elkjs/lib/elk.bundled.js')).default;\n    elk = new ELK();\n  }\n  // Add temporary render element\n  diagObj.db.clear();\n  nodeDb = {};\n  diagObj.db.setGen('gen-2');\n  // Parse the graph definition\n  diagObj.parser.parse(text);\n\n  const renderEl = select('body').append('div').attr('style', 'height:400px').attr('id', 'cy');\n  let graph = {\n    id: 'root',\n    layoutOptions: {\n      'elk.hierarchyHandling': 'INCLUDE_CHILDREN',\n      'org.eclipse.elk.padding': '[top=100, left=100, bottom=110, right=110]',\n      'elk.layered.spacing.edgeNodeBetweenLayers': '30',\n      // 'elk.layered.mergeEdges': 'true',\n      'elk.direction': 'DOWN',\n      // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n    },\n    children: [],\n    edges: [],\n  };\n  log.info('Drawing flowchart using v3 renderer', elk);\n\n  // Set the direction,\n  // Fetch the default direction, use TD if none was found\n  let dir = diagObj.db.getDirection();\n  switch (dir) {\n    case 'BT':\n      graph.layoutOptions['elk.direction'] = 'UP';\n      break;\n    case 'TB':\n      graph.layoutOptions['elk.direction'] = 'DOWN';\n      break;\n    case 'LR':\n      graph.layoutOptions['elk.direction'] = 'RIGHT';\n      break;\n    case 'RL':\n      graph.layoutOptions['elk.direction'] = 'LEFT';\n      break;\n  }\n  const { securityLevel, flowchart: conf } = getConfig();\n\n  // Find the root dom node to ne used in rendering\n  // Handle root and document for when rendering in sandbox mode\n  let sandboxElement;\n  if (securityLevel === 'sandbox') {\n    sandboxElement = select('#i' + id);\n  }\n  const root =\n    securityLevel === 'sandbox'\n      ? select(sandboxElement.nodes()[0].contentDocument.body)\n      : select('body');\n  const doc = securityLevel === 'sandbox' ? sandboxElement.nodes()[0].contentDocument : document;\n\n  const svg = root.select(`[id=\"${id}\"]`);\n\n  // Define the supported markers for the diagram\n  const markers = ['point', 'circle', 'cross'];\n\n  // Add the marker definitions to the svg as marker tags\n  insertMarkers(svg, markers, diagObj.type, diagObj.arrowMarkerAbsolute);\n\n  // Fetch the vertices/nodes and edges/links from the parsed graph definition\n  const vert = diagObj.db.getVertices();\n\n  // Setup nodes from the subgraphs with type group, these will be used\n  // as nodes with children in the subgraph\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info('Subgraphs - ', subGraphs);\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(subG.id, subG.title, 'group', undefined, subG.classes, subG.dir);\n  }\n\n  // Add an element in the svg to be used to hold the subgraphs container\n  // elements\n  const subGraphsEl = svg.insert('g').attr('class', 'subgraphs');\n\n  // Create the lookup db for the subgraphs and their children to used when creating\n  // the tree structured graph\n  const parentLookupDb = addSubGraphs(diagObj.db);\n\n  // Add the nodes to the graph, this will entail creating the actual nodes\n  // in order to get the size of the node. You can't get the size of a node\n  // that is not in the dom so we need to add it to the dom, get the size\n  // we will position the nodes when we get the layout from elkjs\n  graph = addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n\n  // Time for the edges, we start with adding an element in the node to hold the edges\n  const edgesEl = svg.insert('g').attr('class', 'edges edgePath');\n  // Fetch the edges form the parsed graph definition\n  const edges = diagObj.db.getEdges();\n\n  // Add the edges to the graph, this will entail creating the actual edges\n  graph = addEdges(edges, diagObj, graph, svg);\n\n  // Iterate through all nodes and add the top level nodes to the graph\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach((nodeId) => {\n    const node = nodeDb[nodeId];\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n    // Subgraph\n    if (parentLookupDb.childrenById[nodeId] !== undefined) {\n      node.labels = [\n        {\n          text: node.labelText,\n          layoutOptions: {\n            'nodeLabels.placement': '[H_CENTER, V_TOP, INSIDE]',\n          },\n          width: node.labelData.width,\n          height: node.labelData.height,\n        },\n      ];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info('after layout', JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info('after layout', g);\n  g.edges?.map((edge) => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb);\n  });\n  setupGraphViewbox({}, svg, conf.diagramPadding, conf.useMaxWidth);\n  // Remove element after layout\n  renderEl.remove();\n};\n\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function (node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height,\n      };\n      if (node.type === 'group') {\n        const subgraphEl = subgraphsEl.insert('g').attr('class', 'subgraph');\n        subgraphEl\n          .insert('rect')\n          .attr('class', 'subgraph subgraph-lvl-' + (depth % 5) + ' node')\n          .attr('x', node.x + relX)\n          .attr('y', node.y + relY)\n          .attr('width', node.width)\n          .attr('height', node.height);\n        const label = subgraphEl.insert('g').attr('class', 'label');\n        label.attr(\n          'transform',\n          `translate(${node.labels[0].x + relX + node.x}, ${node.labels[0].y + relY + node.y})`\n        );\n        label.node().appendChild(node.labelData.labelNode);\n\n        log.info('Id (UGH)= ', node.type, node.labels);\n      } else {\n        log.info('Id (UGH)= ', node.id);\n        node.el.attr(\n          'transform',\n          `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`\n        );\n      }\n    }\n  });\n  nodeArray.forEach(function (node) {\n    if (node && node.type === 'group') {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\n\nexport default {\n  getClasses,\n  draw,\n};\n", "/** Returns the styles given options */\nexport interface FlowChartStyleOptions {\n  arrowheadColor: string;\n  border2: string;\n  clusterBkg: string;\n  clusterBorder: string;\n  edgeLabelBackground: string;\n  fontFamily: string;\n  lineColor: string;\n  mainBkg: string;\n  nodeBorder: string;\n  nodeTextColor: string;\n  tertiaryColor: string;\n  textColor: string;\n  titleColor: string;\n  [key: string]: string;\n}\n\nconst genSections = (options: FlowChartStyleOptions) => {\n  let sections = '';\n\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n  return sections;\n};\n\nconst getStyles = (options: FlowChartStyleOptions) =>\n  `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.5;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n  ${genSections(options)}\n`;\n\nexport default getStyles;\n", "// @ts-ignore: JISON typing missing\nimport parser from '../parser/flow';\n\nimport * as db from '../flowDb';\nimport renderer from './flowRenderer-elk';\nimport styles from './styles';\n\nexport const diagram = {\n  db,\n  renderer,\n  parser,\n  styles,\n};\n"],
  "mappings": "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",
  "names": ["styles", "node", "portPos", "db", "conf"]
}
